{:paths ["src/babashka" "src/shared"]

 :tasks
 {:requires
  ([clojure.string :as string]
   [clj-yaml.core :as yaml]
   [dinsro.commands :refer :all]
   [dinsro.helm.bitcoind :as h.bitcoind]
   [dinsro.helm.lnd :as h.lnd]
   [dinsro.helm.nbxplorer :as h.nbxplorer]
   [dinsro.helm.rtl :as h.rtl]
   [dinsro.helm.specter :as h.specter])

  _8
  {:doc  "Summons bot"
   :task (eight)}

  all
  {:depends [init install]}

  build-dev-image
  {:doc  "Build dev image"
   :task (earthly :dev-image)}

  build-image
  {:doc  "Build production image"
   :task (earthly :image {:interactive true})}

  build-production
  {:depends [compile-production package-jar]}

  ci
  {:task (earthly :ci {:interactive true
                       :privileged  true})}

  ci-local
  {:depends [kondo check test]}

  clean
  {:doc  "Clean all the things"
   :task (do
           (shell "rm -rf resources/main/public/js")
           (shell "rm -rf resources/main/public/js")
           (shell "rm -rf resources/workspaces/public/js")
           (shell "rm -rf .shadow-cljs/builds")
           (shell "rm -rf classes/*")
           (shell "rm -rf target"))}

  clean-data
  {:doc  "Cleans the database"
   :task (shell "rm -rf data")}

  check
  {:doc  "Check sources are formatted correctly"
   :task (cljfmt ["src" "deps.edn" "shadow-cljs.edn"])}

  compile
  {:doc     "Compile all source files"
   :depends [compile-clj compile-cljs]}

  compile-clj
  {:doc     "Compile clojure source files"
   :depends [init]}

  compile-cljs
  {:doc     "Compile clojurescript source files"
   :depends [init]
   :task    (let [devtools-url "http://devtools2.dinsro.dev.kronkltd.net"
                  data         {:devtools {:devtools-url devtools-url}}
                  args         (format "-M:dev:shadow-cljs compile main --config-merge '%s'"
                                       (pr-str data))]
              (clojure args))}

  compile-production
  {:doc     "Compile all source files for production"
   :depends [compile-production-clj compile-production-cljs]}

  compile-production-clj
  {:doc  "Compile clojure source files for production"
   :task (do
           (shell "mkdir -p classes")
           (clojure "-M:production -e " "(compile 'dinsro.core)"))}

  compile-production-cljs
  {:doc     "Compile clojurescript source files for production"
   :depends [install]
   :task    (clojure "-M:shadow-cljs release main")}

  dev
  {:doc     "Build and start development server via docker"
   :depends [build-dev-image start-dev]}

  dev-bootstrap
  {:doc "Start clojurescript watch and main server"
   :task
   (let [user          "circleci"
         group         "circleci"
         src-path      "/var/lib/dinsro"
         cert-path     "/mnt/certs"
         sudo          (fn [cmd] (format "sudo -u %s %s" user cmd))
         chown-fn      (fn [data-path] (format "chown -R %s:%s %s" user group data-path))
         chown-cmd1    (chown-fn src-path)
         chown-cmd2    (chown-fn cert-path)
         envs          (->> (migrate-env ["DEVTOOLS_URL" "DINSRO_USE_NOTEBOOK" "WATCH_SOURCES"])
                            (filter identity)
                            (string/join " "))
         bootstrap-cmd (str envs " bb dev-bootstrap-user")]
     (shell (str "mkdir -p " cert-path))
     (shell chown-cmd1)
     (shell chown-cmd2)
     (shell (sudo bootstrap-cmd)))}

  dev-bootstrap-user
  {:task
   (let [watch-sources (boolean (System/getenv "WATCH_SOURCES"))]
     (println "=========================================================================================")
     (let [envs        (->> (concat
                             (migrate-env ["DEVTOOLS_URL" "DINSRO_USE_NOTEBOOK"])
                             ["CONFIG_FILE=/etc/dinsro/config.edn"])
                            (filter identity)
                            (clojure.string/join " "))
           compile-cmd "sh -c \"CONFIG_FILE=/etc/dinsro/config.edn bb compile-cljs\""
           watch-cmd   (str "sh -c \"" envs " bb watch-cljs\"")
           run-cmd     "sh -c \"CONFIG_FILE=/etc/dinsro/config.edn bb run\""]
       (when watch-sources
         (println "watching sources")
         (shell compile-cmd)
         (future (shell watch-cmd)))
       (shell run-cmd)))}

  dispatch
  {:doc  "Send a signal over nrepl"
   :task (clojure (str "-Mdispatch -m dinsro.components.dispatch "
                       (string/join " " (map (fn [x] (str "\"" x "\"")) *command-line-args*))))}

  display-path
  {:doc  "Display dependency trees for each alias"
   :task (doseq [alias ["cljfmt" "dev" "eastwood" "kibit" "production"
                        "shadow-cljs" "test" "uberdeps"]]
           (shell (str "clojure -A:" alias " -Stree")))}

  e2e
  {:doc  "Run end to end testing"
   :task (earthly :e2e {:privileged true})}

  eastwood
  {:doc  "Lint source code with eastwood"
   :task (clojure "-M:dev:eastwood '{:source-paths [\"src/main\" \"src/test\"]}'")}

  format
  {:doc  "Format source files"
   :task (clojure "-M:cljfmt fix src deps.edn shadow-cljs.edn --indents indentation.edn")}

  generate-bitcoind-values
  {:doc "generate a bitcoind values file"
   :task
   (let [n       (or (first *command-line-args*) "3")
         options {:name n}
         yaml    (yaml/generate-string (h.bitcoind/->values options))]
     (mkdir (format "conf/%s" n))
     (spit (format "conf/%s/bitcoind_values.yaml" n) yaml))}

  generate-lnd-values
  {:doc "generate a lnd values file"
   :task
   (let [n       (or (first *command-line-args*) "3")
         options {:alias   (str "Node " n)
                  :name    n
                  :ingress {:host (str "lnd-" n ".localhost")}
                  :rpc     {:host (str "bitcoin.bitcoin-" n)}}
         yaml    (yaml/generate-string (h.lnd/->values options))]
     (mkdir (format "conf/%s" n))
     (spit (format "conf/%s/lnd_values.yaml" n) yaml))}

  generate-nbxplorer-values
  {:doc "generate a nbxplorer values file"
   :task
   (let [n       (or (first *command-line-args*) "3")
         options {:host         (format "nbxplorer-%s.localhost" n)
                  :rpcurl       (format "http://bitcoin.bitcoin-%s:18443" n)
                  :nodeEndpoint (format "bitcoin.bitcoin-%s:18444" n)}
         yaml    (yaml/generate-string (h.nbxplorer/->values options))]
     (mkdir (format "conf/%s" n))
     (spit (format "conf/%s/nbxplorer_values.yaml" n) yaml))}

  generate-rtl-values
  {:doc "generate a rtl values file"
   :task
   (let [n       (or (first *command-line-args*) "3")
         options {:name n}
         yaml    (yaml/generate-string (h.rtl/->values options))]
     (mkdir (format "conf/%s" n))
     (spit (format "conf/%s/rtl_values.yaml" n) yaml))}

  generate-specter-values
  {:doc "generate a specter values file"
   :task
   (let [n       (or (first *command-line-args*) "3")
         options {:name n}
         yaml    (yaml/generate-string (h.specter/->values options))]
     (mkdir (format "conf/%s" n))
     (spit (format "conf/%s/specter_values.yaml" n) yaml))}

  generate-values
  {:doc "generate a lnd values file"
   :task
   (let [n (or (first *command-line-args*) "3")]
     (mkdir (format "conf/%s" n))
     (spit (format "lnd_%s_values.yaml" n)
           (yaml/generate-string
            (h.lnd/->values
             {:alias       (format "Node %s" n)
              :auto-unlock {:password "unlockpassword"}
              :chain       :regtest
              :ingress     {:host (format "lnd-%s.localhost" n)}
              :tls         {:domain (format "lnd-%s-internal.lnd1.svc.cluster.local" n)}}))))}

  helm-bitcoin
  {:depends [generate-bitcoind-values]
   :task
   (let [n        (or (first *command-line-args*) "3")
         path     "resources/helm/fold/charts/bitcoind/"
         filename (format "conf/%s/bitcoind_values.yaml" n)
         cmd      (string/join
                   " "
                   ["helm template "
                    "--create-namespace"
                    (str "--namespace " n)
                    (str "--name-template=bitcoin")
                    (str "--values " filename)
                    path])]
     (shell cmd))}

  helm-bitcoin-apply
  {:task
   (let [n   (or (first *command-line-args*) "3")
         cmd (format "bb helm-bitcoin %s | kubectl apply -n bitcoin-%s -f -" n n)]
     (create-namespace (str "bitcoin-" n))
     (shell (format "sh -c \"%s\"" cmd)))}

  helm-bitcoin-remove
  {:task
   (let [n (or (first *command-line-args*) "3")]
     (delete-namespace (str "bitcoin-" n)))}

  helm-clean
  {:task
   (let [n (or (first *command-line-args*) "3")]
     (try
       (run 'helm-nbxplorer-remove)
       (catch Exception ex
         (println "failed")))
     (try
       (run 'helm-rtl-remove)
       (catch Exception ex
         (println "failed")))
     (try
       (run 'helm-specter-remove)
       (catch Exception ex
         (println "failed")))
     (try
       (run 'helm-lnd-remove)
       (catch Exception ex
         (println "failed")))
     (try
       (run 'helm-bitcoin-remove)
       (catch Exception ex
         (println "failed"))))}

  helm-up
  {:task
   (let [n (or (first *command-line-args*) "3")]
     (try
       (run 'helm-bitcoin-apply)
       (catch Exception ex
         (println "failed")))
     (try
       (run 'helm-lnd-apply)
       (catch Exception ex
         (println "failed")))
     (try
       (run 'helm-specter-apply)
       (catch Exception ex
         (println "failed")))
     (try
       (run 'helm-rtl-apply)
       (catch Exception ex
         (println "failed")))
     (try
       (run 'helm-nbxplorer-apply)
       (catch Exception ex
         (println "failed"))))}

  helm-lnd
  {:depends [generate-lnd-values]
   :task
   (let [n        (or (first *command-line-args*) "3")
         path     "resources/helm/fold/charts/lnd/"
         filename (format "conf/%s/lnd_values.yaml" n)
         cmd      (string/join
                   " "
                   ["helm template "
                    (str "--name-template=lnd-" n)
                    (str "--values " filename)
                    path])]
     (shell cmd))}

  helm-lnd-apply
  {:task
   (let [n   (or (first *command-line-args*) "3")
         cmd (format "bb helm-lnd %s | kubectl apply -n lnd-%s -f -" n n)]
     (create-namespace (str "lnd-" n))
     (shell (format "sh -c \"%s\"" cmd)))}

  helm-lnd-remove
  {:task
   (let [n (or (first *command-line-args*) "3")]
     (delete-namespace (str "lnd-" n)))}

  helm-nbxplorer
  {:depends [generate-nbxplorer-values]
   :task
   (let [n        (or (first *command-line-args*) "3")
         options  {}
         path     "resources/helm/nbxplorer"
         filename (format "conf/%s/nbxplorer_values.yaml" n)
         cmd      (string/join
                   " "
                   ["helm template"
                    (str "--values " filename)
                    (format "--namespace nbxplorer-%s" n)
                    "--name-template=nbxplorer"
                    path])]
     (shell cmd))}

  helm-nbxplorer-apply
  {:task
   (let [n   (or (first *command-line-args*) "3")
         cmd (format "bb helm-nbxplorer %s | kubectl apply -n nbxplorer-%s -f -" n n)]
     (create-namespace (str "nbxplorer-" n))
     (shell (format "sh -c \"%s\"" cmd)))}

  helm-nbxplorer-remove
  {:task
   (let [n (or (first *command-line-args*) "3")]
     (delete-namespace (str "nbxplorer-" n)))}


  helm-rtl
  {:depends [generate-rtl-values]
   :task
   (let [n        (or (first *command-line-args*) "3")
         path     "resources/helm/rtl/"
         filename (format "conf/%s/rtl_values.yaml" n)
         cmd      (string/join
                   " "
                   ["helm template "
                    (str "--name-template=rtl-" n)
                    (str "--values " filename)
                    path])]
     (shell cmd))}

  helm-rtl-apply
  {:task
   (let [n   (or (first *command-line-args*) "3")
         cmd (format "bb helm-rtl %s | kubectl apply -n rtl-%s -f -" n n)]
     (create-namespace (str "rtl-" n))
     (shell (format "sh -c \"%s\"" cmd)))}

  helm-rtl-remove
  {:task
   (let [n (or (first *command-line-args*) "3")]
     (delete-namespace (str "rtl-" n)))}


  helm-specter
  {:depends [generate-specter-values]
   :task
   (let [n        (or (first *command-line-args*) "3")
         path     "resources/helm/specter-desktop/"
         filename (format "conf/%s/specter_values.yaml" n)
         cmd      (string/join
                   " "
                   ["helm template "
                    (str "--name-template=specter-" n)
                    (str "--values " filename)
                    path])]
     (shell cmd))}

  helm-specter-apply
  {:task
   (let [n   (or (first *command-line-args*) "3")
         cmd (format "bb helm-specter %s | kubectl apply -n specter-%s -f -" n n)]
     (create-namespace (str "specter-" n))
     (shell (format "sh -c \"%s\"" cmd)))}

  helm-specter-remove
  {:task
   (let [n (or (first *command-line-args*) "3")]
     (delete-namespace (str "specter-" n)))}

  init
  {:doc     "Initialize the system"
   :depends [install init-bb]}

  init-bb
  {:doc  "Initialize babashka"
   ;; While simple, this command has the side-effect of ensuring that all the
   ;; libraries are ready to be loaded.
   :task (clojure "-e" ":compiled")}

  install
  {:doc  "Install js dependencies"
   :task (shell "yarn install --frozen-lockfile")}

  kibit
  {:doc  "Lint source code with kibit"
   :task (clojure "-M:dev:kibit --paths src/main,src/test")}

  kondo
  {:doc  "Lint source code with clj-kondo"
   :task (shell "npx clj-kondo --parallel --lint \"src/main:src/test\"")}

  lint
  {:depends [kondo eastwood kibit]}

  package-jar
  {:doc  "Build production jar"
   :task (clojure "-M:uberdeps:production --main-class dinsro.core --aliases production")}

  prepare-test-dirs
  {:doc  "Build test data directory"
   :task (shell "mkdir -p /tmp/dinsro/data/test")}

  repl (clojure.main/repl)

  restart
  {:doc "Send a restart signal over nrepl"
   :task
   (binding [*command-line-args* '("(restart)")]
     (run 'dispatch))}

  run
  {:doc  "Run server in dev mode"
   :task (clojure "-M:dev:dev-main")}

  run-production
  {:doc  "Run server from jar"
   :task (shell "java -jar target/dinsro.jar")}

  seed
  {:doc "Seed the database over nrepl"
   :task
   (binding [*command-line-args* '("(dinsro.seed/seed-db!)")]
     (run 'dispatch))}

  server
  {:doc     "compile and run server in dev mode"
   :depends [compile run]}

  start-dev
  {:doc     "Start development"
   :depends [start-lb start-web]}

  start-lb
  {:doc  "Run the load balancer"
   :task (shell "docker-compose up -d frontend")}

  start-web
  {:doc  "Start the main server"
   :task (do
           (shell "mkdir -p data")
           (shell "docker-compose up dinsro"))}

  test
  {:doc     "Run all tests"
   :depends [test-clj test-cljs]}

  test-clj
  {:doc  "Run clojure tests"
   :task (clojure "-M:dev -m kaocha.runner")}

  test-cljs
  {:doc  "Run clojurescript tests"
   :task (do
           (clojure "-M:dev:test:shadow-cljs compile ci")
           (shell "npx karma start --single-run --check=\"ci.js\""))}

  watch {:depends [watch-cljs]}

  watch-cljs
  {:task (let [devtools-url (or (System/getenv "DEVTOOLS_URL") "http://devtools.dinsro.localhost")
               data         {:devtools {:devtools-url devtools-url}}
               args         (format "-M:dev:shadow-cljs watch main workspaces --config-merge '%s'"
                                    (pr-str data))]
           (clojure args))}

  workspaces
  {:task (let [devtools-url (or (System/getenv "DEVTOOLS_URL") "http://devtools.dinsro.localhost")
               data         {:devtools {:devtools-url devtools-url}}
               args         (format "-M:dev:shadow-cljs watch workspaces --config-merge '%s'"
                                    (pr-str data))]
           (clojure args))}}}
